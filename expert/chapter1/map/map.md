### Hash冲突
> 当两个或以上数量的键被"Hash"到了同一个bucket时，我们称这些键发生了冲突,Go使用链地址法来解决冲突。

![](../../../resource/map-03-struct_sketch.png)
### 负载因子
负载因子用于衡量一个Hash表的冲突情况，公式为:
>负载因子=键数量/bucket数量
> 
负载因子过小,说明空间利用率低

>负载因子过小,可能时预分配的空间太大，也可能时大部分元素被删除导致的。随着元素不断添加到map中,
> 
> 负载因子会逐渐升高

负载因子过大,说明冲突严重,存取效率低
>当Hash表的负载因子过大时,需要申请更多的bucket，并对所有的键值对重新组织,使其均匀分布到这些bucket中，
> 
> 这个过程称为rehash
> 
>go语言在负载因子达到6.5时才会触发rehash(redis中map的bucket只能存一个键值对,所以负载因子大于1时
>
>就会触发rehash,而go中map的bucket可以存储8个键值对,所以可以容忍更大的负载因子。 

###扩容
#### 扩容条件
>1.负载因子大于6.5时，即平均每个bucket存储的键值对达到6.5个以上
> 

>2.overflow的数量达到2^min(15,B)时
> 

####增量扩容
>当负载因子过大时，就新建一个bucket数组,新的bucket数组的长度是原来的2倍，然后旧bucket数组中的数据
> 搬迁到新的bucket数组中。
> 
> 考虑到如果map存储了数以亿计的键值对,那么一次性搬迁会造成比较大的延迟,所以Go采用逐步搬迁策略,即每次
> 访问map时都会触发一次搬迁,每次搬迁两个键值对。

####等量扩容
>所谓等量扩容，并不是扩大容量，而是bucket数量不变,重新做一次类似增量扩容的搬迁动作,把松散的键值对
> 重新排列一次,以使bucket的使用率更高，进而保证更快的存取速度。